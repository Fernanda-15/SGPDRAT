function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

<<<<<<< HEAD
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
=======
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
>>>>>>> main

import SockJS from "../modules/sockjs-client/index.js";
import { log } from "../utils/log.js";

var SockJSClient = /*#__PURE__*/function () {
<<<<<<< HEAD
  /**
   * @param {string} url
   */
=======
>>>>>>> main
  function SockJSClient(url) {
    _classCallCheck(this, SockJSClient);

    // SockJS requires `http` and `https` protocols
    this.sock = new SockJS(url.replace(/^ws:/i, "http:").replace(/^wss:/i, "https:"));

<<<<<<< HEAD
    this.sock.onerror =
    /**
     * @param {Error} error
     */
    function (error) {
      log.error(error);
    };
  }
  /**
   * @param {(...args: any[]) => void} f
   */

=======
    this.sock.onerror = function (error) {
      log.error(error);
    };
  }
>>>>>>> main

  _createClass(SockJSClient, [{
    key: "onOpen",
    value: function onOpen(f) {
      this.sock.onopen = f;
    }
<<<<<<< HEAD
    /**
     * @param {(...args: any[]) => void} f
     */

=======
>>>>>>> main
  }, {
    key: "onClose",
    value: function onClose(f) {
      this.sock.onclose = f;
    } // call f with the message string as the first argument

<<<<<<< HEAD
    /**
     * @param {(...args: any[]) => void} f
     */

  }, {
    key: "onMessage",
    value: function onMessage(f) {
      this.sock.onmessage =
      /**
       * @param {Error & { data: string }} e
       */
      function (e) {
=======
  }, {
    key: "onMessage",
    value: function onMessage(f) {
      this.sock.onmessage = function (e) {
>>>>>>> main
        f(e.data);
      };
    }
  }]);

  return SockJSClient;
}();

export { SockJSClient as default };