<<<<<<< HEAD
{"version":3,"file":"resolve-uri.umd.js","sources":["../../src/resolve-uri.ts"],"sourcesContent":["// Matches the scheme of a URL, eg \"http://\"\nconst schemeRegex = /^[\\w+.-]+:\\/\\//;\n\n/**\n * Matches the parts of a URL:\n * 1. Scheme, including \":\", guaranteed.\n * 2. User/password, including \"@\", optional.\n * 3. Host, guaranteed.\n * 4. Port, including \":\", optional.\n * 5. Path, including \"/\", optional.\n */\nconst urlRegex = /^([\\w+.-]+:)\\/\\/([^@/#?]*@)?([^:/#?]*)(:\\d+)?(\\/[^#?]*)?/;\n\ntype Url = {\n  scheme: string;\n  user: string;\n  host: string;\n  port: string;\n  path: string;\n  relativePath: boolean;\n};\n\nfunction isAbsoluteUrl(input: string): boolean {\n  return schemeRegex.test(input);\n}\n\nfunction isSchemeRelativeUrl(input: string): boolean {\n  return input.startsWith('//');\n}\n\nfunction isAbsolutePath(input: string): boolean {\n  return input.startsWith('/');\n}\n\nfunction parseAbsoluteUrl(input: string): Url {\n  const match = urlRegex.exec(input)!;\n  return {\n    scheme: match[1],\n    user: match[2] || '',\n    host: match[3],\n    port: match[4] || '',\n    path: match[5] || '/',\n    relativePath: false,\n  };\n}\n\nfunction parseUrl(input: string): Url {\n  if (isSchemeRelativeUrl(input)) {\n    const url = parseAbsoluteUrl('http:' + input);\n    url.scheme = '';\n    return url;\n  }\n  if (isAbsolutePath(input)) {\n    const url = parseAbsoluteUrl('http://foo.com' + input);\n    url.scheme = '';\n    url.host = '';\n    return url;\n  }\n  if (!isAbsoluteUrl(input)) {\n    const url = parseAbsoluteUrl('http://foo.com/' + input);\n    url.scheme = '';\n    url.host = '';\n    url.relativePath = true;\n    return url;\n  }\n  return parseAbsoluteUrl(input);\n}\n\nfunction stripPathFilename(path: string): string {\n  // If a path ends with a parent directory \"..\", then it's a relative path with excess parent\n  // paths. It's not a file, so we can't strip it.\n  if (path.endsWith('/..')) return path;\n  const index = path.lastIndexOf('/');\n  return path.slice(0, index + 1);\n}\n\nfunction mergePaths(url: Url, base: Url) {\n  // If we're not a relative path, then we're an absolute path, and it doesn't matter what base is.\n  if (!url.relativePath) return;\n\n  normalizePath(base);\n\n  // If the path is just a \"/\", then it was an empty path to begin with (remember, we're a relative\n  // path).\n  if (url.path === '/') {\n    url.path = base.path;\n  } else {\n    // Resolution happens relative to the base path's directory, not the file.\n    url.path = stripPathFilename(base.path) + url.path;\n  }\n\n  // If the base path is absolute, then our path is now absolute too.\n  url.relativePath = base.relativePath;\n}\n\n/**\n * The path can have empty directories \"//\", unneeded parents \"foo/..\", or current directory\n * \"foo/.\". We need to normalize to a standard representation.\n */\nfunction normalizePath(url: Url) {\n  const { relativePath } = url;\n  const pieces = url.path.split('/');\n\n  // We need to preserve the first piece always, so that we output a leading slash. The item at\n  // pieces[0] is an empty string.\n  let pointer = 1;\n\n  // Positive is the number of real directories we've output, used for popping a parent directory.\n  // Eg, \"foo/bar/..\" will have a positive 2, and we can decrement to be left with just \"foo\".\n  let positive = 0;\n\n  // We need to keep a trailing slash if we encounter an empty directory (eg, splitting \"foo/\" will\n  // generate `[\"foo\", \"\"]` pieces). And, if we pop a parent directory. But once we encounter a\n  // real directory, we won't need to append, unless the other conditions happen again.\n  let addTrailingSlash = false;\n\n  for (let i = 1; i < pieces.length; i++) {\n    const piece = pieces[i];\n\n    // An empty directory, could be a trailing slash, or just a double \"//\" in the path.\n    if (!piece) {\n      addTrailingSlash = true;\n      continue;\n    }\n\n    // If we encounter a real directory, then we don't need to append anymore.\n    addTrailingSlash = false;\n\n    // A current directory, which we can always drop.\n    if (piece === '.') continue;\n\n    // A parent directory, we need to see if there are any real directories we can pop. Else, we\n    // have an excess of parents, and we'll need to keep the \"..\".\n    if (piece === '..') {\n      if (positive) {\n        addTrailingSlash = true;\n        positive--;\n        pointer--;\n      } else if (relativePath) {\n        // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute\n        // URL, protocol relative URL, or an absolute path, we don't need to keep excess.\n        pieces[pointer++] = piece;\n      }\n      continue;\n    }\n\n    // We've encountered a real directory. Move it to the next insertion pointer, which accounts for\n    // any popped or dropped directories.\n    pieces[pointer++] = piece;\n    positive++;\n  }\n\n  let path = '';\n  for (let i = 1; i < pointer; i++) {\n    path += '/' + pieces[i];\n  }\n  if (!path || (addTrailingSlash && !path.endsWith('/..'))) {\n    path += '/';\n  }\n  url.path = path;\n}\n\n/**\n * Attempts to resolve `input` URL/path relative to `base`.\n */\nexport default function resolve(input: string, base: string | undefined): string {\n  if (!input && !base) return '';\n\n  const url = parseUrl(input);\n\n  // If we have a base, and the input isn't already an absolute URL, then we need to merge.\n  if (base && !url.scheme) {\n    const baseUrl = parseUrl(base);\n    url.scheme = baseUrl.scheme;\n    // If there's no host, then we were just a path.\n    if (!url.host || baseUrl.scheme === 'file:') {\n      // The host, user, and port are joined, you can't copy one without the others.\n      url.user = baseUrl.user;\n      url.host = baseUrl.host;\n      url.port = baseUrl.port;\n    }\n    mergePaths(url, baseUrl);\n  }\n\n  normalizePath(url);\n\n  // If the input (and base, if there was one) are both relative, then we need to output a relative.\n  if (url.relativePath) {\n    // The first char is always a \"/\".\n    const path = url.path.slice(1);\n    if (!path) return '.';\n\n    // If base started with a leading \".\", or there is no base and input started with a \".\", then we\n    // need to ensure that the relative path starts with a \".\". We don't know if relative starts\n    // with a \"..\", though, so check before prepending.\n    const keepRelative = (base || input).startsWith('.');\n    return !keepRelative || path.startsWith('.') ? path : './' + path;\n  }\n  // If there's no host (and no scheme/user/port), then we need to output an absolute path.\n  if (!url.scheme && !url.host) return url.path;\n  // We're outputting either an absolute URL, or a protocol relative one.\n  return `${url.scheme}//${url.user}${url.host}${url.port}${url.path}`;\n}\n"],"names":[],"mappings":"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"}
=======
{"version":3,"file":"resolve-uri.umd.js","sources":["../src/resolve-uri.ts"],"sourcesContent":["type WhatWgUrl = import('url').URL;\ninterface Url extends WhatWgUrl {\n  new (input: string, base?: string): WhatWgUrl;\n}\ndeclare var URL: unknown;\n\n/* istanbul ignore next */\nconst Url = (typeof URL !== 'undefined' ? URL : require('url').URL) as Url;\n\n// Matches \"..\", which must be preceeded by \"/\" or the start of the string, and\n// must be followed by a \"/\". We do not eat the following \"/\", so that the next\n// iteration can match on it.\nconst parentRegex = /(^|\\/)\\.\\.(?=\\/|$)/g;\n\nfunction isAbsoluteUrl(url: string): boolean {\n  try {\n    return !!new Url(url);\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * Creates a directory name that is guaranteed to not be in `str`.\n */\nfunction uniqInStr(str: string): string {\n  let uniq = String(Math.random()).slice(2);\n  while (str.indexOf(uniq) > -1) {\n    /* istanbul ignore next */\n    uniq += uniq;\n  }\n  return uniq;\n}\n\n/**\n * Removes the filename from the path (everything trailing the last \"/\"). This\n * is only safe to call on a path, never call with an absolute or protocol\n * relative URL.\n */\nfunction stripPathFilename(path: string): string {\n  path = normalizePath(path);\n  const index = path.lastIndexOf('/');\n  return path.slice(0, index + 1);\n}\n\n/**\n * Normalizes a protocol-relative URL, but keeps it protocol relative by\n * stripping out the protocl before returning it.\n */\nfunction normalizeProtocolRelative(input: string, absoluteBase: string): string {\n  const { href, protocol } = new Url(input, absoluteBase);\n  return href.slice(protocol.length);\n}\n\n/**\n * Normalizes a simple path (one that has no \"..\"s, or is absolute so \"..\"s can\n * be normalized absolutely).\n */\nfunction normalizeSimplePath(input: string): string {\n  const { href } = new Url(input, 'https://foo.com/');\n  return href.slice('https://foo.com/'.length);\n}\n\n/**\n * Normalizes a path, ensuring that excess \"..\"s are preserved for relative\n * paths in the output.\n *\n * If the input is absolute, this will return an absolutey normalized path, but\n * it will not have a leading \"/\".\n *\n * If the input has a leading \"..\", the output will have a leading \"..\".\n *\n * If the input has a leading \".\", the output will not have a leading \".\"\n * unless there are too many \"..\"s, in which case there will be a leading \"..\".\n */\nfunction normalizePath(input: string): string {\n  // If there are no \"..\"s, we can treat this as if it were an absolute path.\n  // The return won't be an absolute path, so it's easy.\n  if (!parentRegex.test(input)) return normalizeSimplePath(input);\n\n  // We already found one \"..\". Let's see how many there are.\n  let total = 1;\n  while (parentRegex.test(input)) total++;\n\n  // If there are \"..\"s, we need to prefix the the path with the same number of\n  // unique directories. This is to ensure that we \"remember\" how many parent\n  // directories we are accessing. Eg, \"../../..\" must keep 3, and \"foo/../..\"\n  // must keep 1.\n  const uniqDirectory = `z${uniqInStr(input)}/`;\n\n  // uniqDirectory is just a \"z\", followed by numbers, followed by a \"/\". So\n  // generating a runtime regex from it is safe. We'll use this search regex to\n  // strip out our uniq directory names and insert any needed \"..\"s.\n  const search = new RegExp(`^(?:${uniqDirectory})*`);\n\n  // Now we can resolve the total path. If there are excess \"..\"s, they will\n  // eliminate one or more of the unique directories we prefix with.\n  const relative = normalizeSimplePath(uniqDirectory.repeat(total) + input);\n\n  // We can now count the number of unique directories that were eliminated. If\n  // there were 3, and 1 was eliminated, we know we only need to add 1 \"..\". If\n  // 2 were eliminated, we need to insert 2 \"..\"s. If all 3 were eliminated,\n  // then we need 3, etc. This replace is guranteed to match (it may match 0 or\n  // more times), and we can count the total match to see how many were eliminated.\n  return relative.replace(search, (all: string) => {\n    const leftover = all.length / uniqDirectory.length;\n    return '../'.repeat(total - leftover);\n  });\n}\n\n/**\n * Attempts to resolve `input` URL relative to `base`.\n */\nexport default function resolve(input: string, base: string | undefined): string {\n  if (!base) base = '';\n\n  // Absolute URLs are very easy to resolve right.\n  if (isAbsoluteUrl(input)) return new Url(input).href;\n\n  if (base) {\n    // Absolute URLs are easy...\n    if (isAbsoluteUrl(base)) return new Url(input, base).href;\n\n    // If base is protocol relative, we'll resolve with it but keep the result\n    // protocol relative.\n    if (base.startsWith('//')) return normalizeProtocolRelative(input, `https:${base}`);\n  }\n\n  // Normalize input, but keep it protocol relative. We know base doesn't supply\n  // a protocol, because that would have been handled above.\n  if (input.startsWith('//')) return normalizeProtocolRelative(input, 'https://foo.com/');\n\n  // We now know that base (if there is one) and input are paths. We've handled\n  // both absolute and protocol-relative variations above.\n\n  // Absolute paths don't need any special handling, because they cannot have\n  // extra \".\" or \"..\"s. That'll all be stripped away. Input takes priority here,\n  // because if input is an absolute path, base path won't affect it in any way.\n  if (input.startsWith('/')) return '/' + normalizeSimplePath(input);\n\n  // Since input and base are paths, we need to join them to do any further\n  // processing. Paths are joined at the directory level, so we need to remove\n  // the base's filename before joining. We also know that input does not have a\n  // leading slash, and that the stripped base will have a trailing slash if\n  // there are any directories (or it'll be empty).\n  const joined = stripPathFilename(base) + input;\n\n  // If base is an absolute path, then input will be relative to it.\n  if (base.startsWith('/')) return '/' + normalizeSimplePath(joined);\n\n  // We now know both base (if there is one) and input are relative paths.\n  const relative = normalizePath(joined);\n\n  // If base started with a leading \".\", or there is no base and input started\n  // with a \".\", then we need to ensure that the relative path starts with a\n  // \".\". We don't know if relative starts with a \"..\", though, so check before\n  // prepending.\n  if ((base || input).startsWith('.') && !relative.startsWith('.')) {\n    return './' + relative;\n  }\n\n  return relative;\n}\n"],"names":[],"mappings":"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"}
>>>>>>> main
